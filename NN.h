#include "pch.h"


SC_MODULE(NN) {

	sc_in<bool> clk;
	sc_signal<int> corer;


	// переменная для подсчета времени выполнения
	int firstly_time = clock();

	//входные данные
	double inputs[36][52] = {
		{0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0, 1,0,0}, //круг
		{0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0, 0,1,0}, //квадрат
		{0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,	0,0,1}, //треугольник 
		//
		{0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,	1,0,0},
		{0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,1,1,1,0,0,0,0,0,0,0,0,	0,1,0},
		{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,	0,0,1},
		{0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,	1,0,0},
		{0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,	0,1,0},
		{0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,	0,0,1},
		{0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,	1,0,0},
		{0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,1,1,1,0,0,0,0,0,0,0,0,	0,1,0},
		{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,	0,0,1},
		{0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,	1,0,0},
		{0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,	0,1,0},
		{0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,	0,0,1},
		{0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,	1,0,0},
		{0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,1,1,1,0,0,0,0,0,0,0,0,	0,1,0},
		{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,	0,0,1},
		{0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,	1,0,0},
		{0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,	0,1,0},
		{0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,	0,0,1},
		{0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,	1,0,0},
		{0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,1,1,1,0,0,0,0,0,0,0,0,	0,1,0},
		{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,	0,0,1},
		{0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,	1,0,0},
		{0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,	0,1,0},
		{0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,	0,0,1},
		{0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,	1,0,0},
		{0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,1,1,1,0,0,0,0,0,0,0,0,	0,1,0},
		{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,	0,0,1},
		{0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,	1,0,0},
		{0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,	0,1,0},
		{0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,	0,0,1},
		{0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,	1,0,0},
		{0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,1,1,1,0,0,0,0,0,0,0,0,	0,1,0},
		{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0, 0,0,1} };

	// nrow служит для перехода по строкам входных данных 
	int nrow = 0;
	// ncol = число равное количеству входов и весов
	int ncol = 49;
	// количество эпох прохождения
	int epoch = 1000;
	//шаг изменения
	double learning_rate = 0.5;
	//веса от скрытого к выходу
	double weight_out[10][3];
	//веса к скрытому слою
	double weight_input[49][10];
	//ошибка в скрытомслое 
	double sigmaHid[10]{};
	//финальные нейроны
	double finNeir[3]{};
	//нйронны скрытого слоя
	double neir[10]{};
	//ошибка финального нейрона
	double sigmFin[3]{};

	void nn() {	

		//веса от входа к скрытому слою
		for (int i = 0; i < 49; i++) {
			for (int j = 0; j < 10; j++) {
				weight_input[i][j] = rand() % 1;
			}
		}
		//веса от скрытого к выходу
		for (int i = 0; i < 10; i++) {
			for (int j = 0; j < 3; j++) {
				weight_out[i][j] = rand() % 3;
			}
		}
		
		//прямое распростанение 	
		for (int i = 0; i < epoch; i++) {
			// нейроны скрытого слоя
			for (nrow = 0; nrow < 3; nrow++) {
				for (int n = 0; n < 10; n++) {
					for (int i = 0; i < ncol; i++) {
						neir[n] += inputs[nrow][i] * weight_input[i][n];
					}
					neir[n] = 1.0 / (1.0 + pow(2.718, -neir[n]));
				}
				// выходные нейроны

				for (int fn = 0; fn < 3; fn++) {
					for (int n = 0; n < 10; n++) {
						finNeir[fn] += neir[n] * weight_out[n][fn];
					}
					finNeir[fn] = 1.0 / (1.0 + pow(2.718, -finNeir[fn]));
					//cout << "finneir" << finNeir[fn] << endl;
				}
				//обучение

				//ошибка на выходе 			
				for (int i = 0; i < 3; i++) {
					sigmFin[i] = finNeir[i] - inputs[nrow][49 + i];
					double sigmoid = finNeir[i] * (1 - finNeir[i]);
					sigmFin[i] = sigmFin[i] * sigmoid;
				}
				//ошибка 10 нейронов 			
				for (int j = 0; j < 10; j++) {
					for (int i = 0; i < 3; i++) {
						sigmaHid[j] += weight_out[j][i] * sigmFin[i];
					}
					double sigmoid = neir[j] * (1 - neir[j]);
					sigmaHid[j] = sigmaHid[j] * sigmoid;
				}
				
				corer.write(nrow);
				wait();
			}
		}
			int secondary_time = clock();
			int finish_time = secondary_time - firstly_time;
			cout << "time: " << finish_time << " ns" << endl;

			cout << endl;
			cout << endl;

			firstly_time = clock();

			//проверка на других фигурах
			for (nrow = 3; nrow < 36; nrow++) {

				// нейроны скрытого слоя
				double neir[10]{};
				for (int n = 0; n < 10; n++) {
					for (int i = 0; i < ncol; i++) {
						neir[n] += inputs[nrow][i] * weight_input[i][n];
					}
					neir[n] = 1.0 / (1.0 + pow(2.718, -neir[n]));
				}
				// выходные нейроны
				for (int fn = 0; fn < 3; fn++) {
					for (int n = 0; n < 9; n++) {
						finNeir[fn] += neir[n] * weight_out[n][fn];
					}
					finNeir[fn] = 1.0 / (1.0 + pow(2.718, -finNeir[fn]));
				}
				cout << "1 myres circle = " << finNeir[0] << "; circle = " << inputs[nrow][49] << endl;
				cout << "2 myres square = " << finNeir[1] << "; square = " << inputs[nrow][50] << endl;
				cout << "3 myres triang = " << finNeir[2] << "; triang = " << inputs[nrow][51] << endl;
				cout << endl;
					

			}
			// время окончания
			secondary_time = clock();
			finish_time = secondary_time - firstly_time;
			cout << "time: " << finish_time << " ns" << endl;			
	};
	
	void CorErH() {
		//меняем веса входных нейронов 10,49 ncol=49	
		for (int j = 0; j < ncol; j++) {
			for (int i = 0; i < 10; i++) {
				weight_input[j][i] = weight_input[j][i] - inputs[nrow][j] * learning_rate * sigmaHid[i];
			}
		}
	}
	void CorErF() {
		//меняем веса нейронов входных 10,3 
		for (int wo = 0; wo < 10; wo++) {
			for (int won = 0; won < 3; won++) {
				weight_out[wo][won] = weight_out[wo][won] - neir[wo] * sigmFin[won] * learning_rate;
			}
		}
	}
	SC_CTOR(NN)
	{
		corer = false;	

		SC_METHOD(CorErH);
		sensitive << corer;
		SC_METHOD(CorErF);
		sensitive << corer;
		
		SC_THREAD(nn);	
		sensitive << clk;
	}
};